####direct交换器
1.原生java客户端使用direct交换器 一般用法

2.原生java客户端使用direct交换器 队列绑定多个路由键用法
 * >一个队列 使用多个路由键与交换器绑定 这些路由键路由的消息都会路由到这个队列上
   
3.原生java客户端使用direct交换器 一个Connection可以创建多个channal 多个队列绑定这同一个交换器 不同消费者消费演示
* >个人误区注意点：即使是direct交换器,如果有多个队列使用符合这个消息的绑定键绑定了同一个交换器,那么这条消息也会被direct交换器都转发到这几个队列上去,符合规则就人人有份,并不会采取什么轮训啊啥的这次发这个下次再发另外一个队列（这是队列和多个消费者的策略之一 别混喽）  
也就意味这即使direct交换器 消费方发送的消息个数 和经过交换器转发给对列的总数量也并不是一定一致。

4.原生java客户端使用direct交换器 一个队列多个消费者
* >则会表现出消息在消费者之间的轮询接收
  
####Fanout 广播交换器
原生java客户端使用Fanout交换器 和绑定键无关
* >Fanout广播交换器 消息传递和绑定键无关 只要队列绑定了这个交换器 都能收到fanout交换器全部消息
  
####**Topic 主题交换器**
原生java客户端使用Topic主题订阅交换器
topic 主题交换器,主题订阅 通过路由键组合匹配 路由键是通过.分割关键字的字符串 其中可以用#和*通配

>\#和*的区别:  
>- \#可以匹配0或多层单词  
>- *只能匹配一个单词

假设现在路由键的规则为 “老师.技术专题.课程章节"，如：king.kafka.A  
则队列queueName订阅TopicProducer.EXCHANGE_NAME的消息：channel.queueBind(queueName,TopicProducer.EXCHANGE_NAME, "#.B");  
订阅内容与之相匹配的路由绑定键规则如下:
>- 订阅所有老师的所有课程的所有章节   “#”
>- 订阅所有老师的所有课程的B章节     “#.B” 
>- 订阅King老师的所有课程的B章节     “king.#” 
>- 订阅所有kafka课程的所有章节      “ \*.kafka.* “
>- 订阅king老师的kafka课程的A章节   “king.kafka.A“
>- 订阅订阅king老师的所有课程的A章节 “king.*.A“

topic的灵活之处体现在：无论是direct交换器还是fanout交换器的功能 它都能模拟代替
  - 当一个队列以”#”作为绑定键时,它将接收所有消息,而不管路由键如何,类似于fanout型交换器
  - 当特殊字符”*”、”#”没有用到绑定时，topic型交换器就好比direct型交换器了
  


